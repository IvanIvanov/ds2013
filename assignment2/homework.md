Домашно 2
==========

## Задачи ##
Решенията на задачите се предават по e-mail на адрес:

> ivan.vladimirov.ivanov@gmail.com

Решенията на всяка задача трябва да бъде под формата на архивен файл (zip или rar), който да съдържа всички .cpp и/или .h файлове необходими за решаването на съответната задача. Като алтернатива архивът може да съдържа и целият проект генериран от вашата среда за разработка, но в този случай може да се наложи да изтриете всики изпълними файлове (като .exe например) за да избегнете антивирусните системи на gmail. Самите архивни файлове се изпращат като attachment-и в mail-а. Освен решения на задачите самият mail трябва да съдържа име и факултетен номер. Успех!

За примерни реализации на свързани списъци и операциите над тях вижте [тук]().

### Задача 1 ###
Да се реализира стек, който вместо на масив да бъде базиран на възли на свързан списък. За целта да се имплементират методите на следния клас:


```C++
template <typename T>
class Stack {
 private:
  struct Node {
    T value;
    Node* next;
    Node(T value, Node* next);
  };
  Node* top;

 public:
  Stack();
  ~Stack();
  bool Push(const T& value);
  bool Pop(T& result);
  bool Top(T& result);
  bool IsEmpty();
};
```

За идеи вижте реализацията на свързан списък [тук]().

Напишете програма, която упражнява реализирания стек. Програмата трябва да симулира двете стандартни операции върху стека:

* **Push value** - която добавя цялото число value към върха на стека.
* **Pop**        - която премахва числото намиращо на върха на стека.

като чете операциите от стандартния вход и пише резултатите от тях на стандартния изход.

**Формат на входа:**

На първия ред на стандартния вход се съдържа единствено цяло число n (0 <= n <= 1000), което указва броя на операциите, които да се симулират. Следват n операции, за Push и Pop, като вида на операцията се определя от едно число което е или 0 (за операцията Push) или 1 (за операцията Pop). Ako операцията е Push (т.е. е зададена с код 0), то кода е последван от още едно цяло число x, където -1000 <= x <= 1000 е числото което трябва да бъде добавено към върха на стека.

**Формат на изхода:**

За всяка операция от тип Pop (т.е. операция зададена с код 1), да се изпечата на отделен ред числото, което е било премахнато в резултат на операцията. Забележка - може да се предполага, че никога няма да бъде дадена операция Pop за празнен стек.

**Примерен вход:**
```
10
0 1
0 2
0 3
1
1
0 4
1
1
0 5
1
```

**Примерен изход:**
```
3
2
4
1
5
```


### Задача 2 ###
Дек ([deque](http://en.wikipedia.org/wiki/Double-ended_queue)) е специална сруктура от данни, която може да имитира, както стек така и опашка. По-конкретно декът поддържа операции за добавяне и махане на елементи както в началото си така и в края си. За да имитираме стек с дек можем да добавяме елемент в началото на дека за всяка операция Push и да махаме елемент от началото на дека за всяка операция Pop. За да имитираме опашка е достатъчно да добавяме елемент към края за всяка операция Push и да махаме елемент от началото на дека за всяка операция Pop.


Да се реализира дек (deque), като се използва реализацията на двусвързания списък представена [тук](). За целта да се имплементират методите на следния клас:

```C++
template <typename T>
class Deque {
 private:
  DoublyLinkedList<T>* list;

 public:
  Deque();
  ~Deque();
  void InsertFront(const T& value);
  void InsertBack(const T& value);
  bool RemoveFront(T& result);
  bool RemoveBack(T& result);
  bool Front(T& result);
  bool Back(T& result);
  bool IsEmpty();
};

```

Напишете програма, която упражнява реализирания дек (deque). Програмата трябва да симулира четирите стандартни операции върху дек:

* **InsertFront value** - която добавя цялото число value към началото на дека.
* **InsertBack  value** - която добавя цялото число value към края на дека.
* **RemoveFront**       - която премахва числото намиращо в началото на дека.
* **RemoveBack**        - която премахва числото намиращо в края на дека.

като чете операциите от стандартния вход и пише резултатите от тях на стандартния изход.

**Формат на входа:**

На първия ред на стандартния вход се съдържа единствено цяло число n (0 <= n <= 1000), което указва броя на операциите, които да се симулират. Следват n операции, за InsertFront, InsertBack, RemoveFront и RemoveBack, като вида на операцията се определя от едно число което е или 0 (за операцията InsertFront) или 1 (за операцията InsertBack) или 2 (за операцията RemoveFront) или 3 (за операцията RemoveBack). Ako операцията е Insert (т.е. е зададена с код 0 или 1), то кода е последван от още едно цяло число x, където -1000 <= x <= 1000 е числото което трябва да бъде добавено към на дека.

**Формат на изхода:**

За всяка операция от тип Remove (т.е. операция зададена с код 2 или 3), да се изпечата на отделен ред числото, което е било премахнато в резултат на операцията. Забележка - може да се предполага, че никога няма да бъде дадена операция Remove за празнен дек.


**Примерен вход:**
```
10
0 1
1 2
0 3
0 4
2
0 5
3
2
3
2
```

**Примерен изход:**
```
4
2
5
1
3
```


